<!DOCTYPE html>
<html lang="en-GB">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<script type='text/javascript' src='http://hellicarstudio.com/wp-includes/js/jquery/jquery.js?ver=1.12.4'></script>
<script type='text/javascript' src='http://hellicarstudio.com/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>
<script type='text/javascript' src='canvas2svg.js'></script>
</head>

<body>
<!-- <image if="logo" src="OxEGen_logo-06.png" style="position: absolute; width: 190px;     padding-top: 140px;
    padding-left: 105px;"> -->
 		<canvas id="glscreen" width="400" height="400"></canvas>
 		<p>Color</p>
 		<label>1</label>
 		<input type="color" id="col1" value="#E2681E">
 		<label>2</label>
 		<input type="color" id="col2" value="#EE9B0F">
 		<label>3</label>
 		<input type="color" id="col3" value="#1B5D43">
 		 <label>4</label>
 		<input type="color" id="col4" value="#E5C12B">
 		 <label>5</label>
 		<input type="color" id="col5" value="#FFDD728">
 		<p></p>
 		<button onclick="randomizeValues()">Randomize Parameters</button>
 		<button onclick="importCanvas()">Save Image</button>
 		<p></p>
 		<script id="2d-vertex-shader" type="x-shader/x-vertex">
		//Vertex Shader, just a pass=through, does nothing out of the ordinary
		attribute vec2 a_position;
  		void main() {
    		gl_Position = vec4(a_position, 0, 1);
  		}
		</script>

 		<script id="2d-fragment-shader" type="x-shader/x-fragment">
		//Fragment shader, does all the work!
		// Here we initialize the float precision (this really should bea  default thing, took me like an hour to figure out)
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
  		#else
    		precision mediump float;
  		#endif

  		// Uniform for the resolution of the CANVAS! (not the screen) and normalized mouse position
  		uniform vec2 u_points[10];
  		uniform vec3 u_colors[10];
  		void main() {
  			//Normalize the frag coord to [0, 1]
  			vec2 uv = gl_FragCoord.xy / vec2(400.0, 400.0);

  			vec2 cPos = vec2(0.5, 0.5);

  			float dist = distance(cPos, uv);

  			float percentages[10];

  			for(int i = 0; i < 10; i++) {
  				float d = distance(u_points[i], uv);
  				float p = 1.0 - smoothstep(0.0, 0.5, d);
  				percentages[i] = p;
  			}

  			// if(dist > 0.5) {
  			// 	gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
  			// 	return;
  			// }

  			//Save out the mouse position (not really necessary but makes it cleaner imo)
  			//vec2 mouse = u_mousePos.xy;

  			//Two colors you want to use, will make this changeable later
    		vec4 colTop = vec4(0.200, 0.600, 0.750, 1.0);
    		vec4 colBot = vec4(0.900, 0.600, 0.600, 1.0);

    		//Calculate the background gradient along y using basic mix function
    		vec4 background = vec4(0.75, 0.68, 0.05, 1.0);
    		for(int i = 0; i < 10; i++) {
    			background.rgb = mix(background.rgb, u_colors[i], percentages[i]);
    		}

    		background = background + smoothstep(0.44, 0.45, dist);

        	//calculate distance to the mouse
    		//float xDiff = mouse.x - uv.x;
    		//float yDiff = mouse.y - uv.y;

    		//float dst = sqrt(xDiff * xDiff + yDiff * yDiff) * 1.5;

    		//Find the mouse color by sampling the background gradient
    		//vec4 mouseCol = colTop * mouse.y + colBot * (1.0 - mouse.y);
    
			gl_FragColor = background;
		}
		</script>

 		<script>
 		// grab the canvas and the gl context
		var canvas = document.getElementById('glscreen');
		var gl = canvas.getContext('experimental-webgl');
		var body = document.body;
		var buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

		gl.bufferData(
			gl.ARRAY_BUFFER, 
			new Float32Array([
					-1.0, -1.0, 
					1.0, -1.0, 
					-1.0,  1.0, 
					-1.0,  1.0, 
					1.0, -1.0, 
					1.0,  1.0]), 
			gl.STATIC_DRAW
		);

		var velocities = getRandomArray(-0.002, 0.002, 20);
		var points = getRandomArray(0.0, 1.0, 20);
		var colors = setColors();

		gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

		//define the shader variables that we'll need
		var shaderScript;
		var shaderSource;
		var vertexShader;
		var fragmentShader;

		// compile the vertex shader
		shaderScript = document.getElementById("2d-vertex-shader");
		shaderSource = shaderScript.text;
		vertexShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vertexShader, shaderSource);
		gl.compileShader(vertexShader);
		
		//compile the fragment shader
		shaderScript   = document.getElementById("2d-fragment-shader");
		shaderSource   = shaderScript.text;
		fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fragmentShader, shaderSource);
		gl.compileShader(fragmentShader);

		program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);	
		gl.useProgram(program);

		setParameters();

		function getRandomArray(low, high, size) {
			var points = new Array();
			for(var i = 0; i < size; i++) {
				points[i] = map_range(Math.random(), 0.0, 1.0, low, high);
			}
			return points;
		}

		function map_range(value, low1, high1, low2, high2) {
    		return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
		}

		function hexToRgb(hex) {
		    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		    return result ? {
		        r: parseInt(result[1], 16),
		        g: parseInt(result[2], 16),
		        b: parseInt(result[3], 16)
		    } : null;
		}

		function setColors() {
			var colors = new Array();
			colors[0] = 0.75;
			colors[1] = 0.68;
			colors[2] = 0.05;

			colors[3] = 0.75;
			colors[4] = 0.72;
			colors[5] = 0.03;

			colors[6] = 1.0;
			colors[7] = 0.96;
			colors[8] = 0.02;

			colors[9] = 0.93;
			colors[10] = 0.99;
			colors[11] = 0.75;

			colors[12] = 0.89;
			colors[13] = 0.95;
			colors[14] = 0.01;

			colors[15] = 0.75;
			colors[16] = 0.68;
			colors[17] = 0.05;

			colors[18] = 0.75;
			colors[19] = 0.72;
			colors[20] = 0.03;

			colors[21] = 1.0;
			colors[22] = 0.96;
			colors[23] = 0.02;

			colors[24] = 0.93;
			colors[25] = 0.99;
			colors[26] = 0.75;

			colors[27] = 0.89;
			colors[28] = 0.95;
			colors[29] = 0.01;

			return colors;
		}



		function animatePoints(points, vels) {
			for(var i = 0; i < points.length; i++) {
				points[i] += vels[i];
				if(points[i] < 0) {
					points[i] = 0;
					vels[i] *= -1;
				}
				if(points[i] > 1) {
					points[i] = 1;
					vels[i] *= -1;
				}
			}
		}

		function downloadURI(uri, name) {
		  var link = document.createElement("a");
		  link.download = name;
		  link.href = uri;
		  document.body.appendChild(link);
		  link.click();
		  document.body.removeChild(link);
		  delete link;
		}

		function importCanvas() {
			var ctxS = new C2S(400, 400);

			drawScene(ctxS);

			var svg = ctxS.getSerializedSvg(true);

			var svg = "data:image/svg+xml;charset=utf-8," + svg;

			downloadURI(svg, "image.svg");
		}

		function setParameters() {
			var cols = new Array();
			cols[0] = document.getElementById("col1").value;
			cols[1] = document.getElementById("col2").value;
			cols[2] = document.getElementById("col3").value;
			cols[3] = document.getElementById("col4").value;
			cols[4] = document.getElementById("col5").value;
			for(var i = 0; i < cols.length; i+=3) {
				colors[i] = hexToRgb(cols[i]).r;
				colors[i+1] = hexToRgb(cols[i]).g;
				colors[i+2] = hexToRgb(cols[i]).b;
			}
		}


		function randomizeValues() {
			// document.getElementById("lineWidth1").value = 1.0 + Math.random()*8.0;
			// document.getElementById("lineWidth2").value = 1.0 + Math.random()*8.0;
			// document.getElementById("lineWidth3").value = 1.0 + Math.random()*8.0;

			// document.getElementById("amp1").value = 0.0 + Math.random()*20.0;
			// document.getElementById("amp2").value = 0.0 + Math.random()*20.0;
			// document.getElementById("amp3").value = 0.0 + Math.random()*20.0;

			// var freq = 1.0 + Math.random()*14.0;
			// document.getElementById("freq1").value = parseInt(2.0 + Math.random()*7.0);
			// document.getElementById("freq2").value = parseInt(2.0 + Math.random()*7.0);
			// document.getElementById("freq3").value = parseInt(2.0 + Math.random()*7.0);
		}

		function animate() {

			setParameters();

			animatePoints(points, velocities);
			//clear the buffer
			gl.clearColor(1.0, 1.0, 1.0, 1.0);
			gl.clear(gl.COLOR_BUFFER_BIT);

			// set vertex shader attributes
			positionLocation = gl.getAttribLocation(program, "a_position");
			gl.enableVertexAttribArray(positionLocation);
			gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

			//set fragment shader uniform
			var pointsLoc = gl.getUniformLocation(program, "u_points");
			//var mouseX = 0.5;
			//var mouseY = 0.5;
			//mouseY = 1.0 - mouseY; // flip mouse y because it comes in upside down for the shader coordinate space.
			gl.uniform2fv(pointsLoc, points);

			var colorsLoc = gl.getUniformLocation(program, "u_colors");
			gl.uniform3fv(colorsLoc, colors);

			//draw the triangles with the shaders!
			gl.drawArrays(gl.TRIANGLES, 0, 6);

			requestAnimationFrame(function() {
				animate();
			});
		}

		animate();
	</script>
</body>
</html>
