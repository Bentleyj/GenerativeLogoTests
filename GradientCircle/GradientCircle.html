<!DOCTYPE html>
<html lang="en-GB">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<script type='text/javascript' src='http://hellicarstudio.com/wp-includes/js/jquery/jquery.js?ver=1.12.4'></script>
<script type='text/javascript' src='http://hellicarstudio.com/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>
<script type='text/javascript' src='canvas2svg.js'></script>
</head>

<body>
<!-- <image if="logo" src="OxEGen_logo-06.png" style="position: absolute; width: 190px;     padding-top: 140px;
    padding-left: 105px;"> -->
 		<canvas id="glscreen" width="400" height="400"></canvas>
 		<p>Color</p>
 		<label>1</label>
 		<input type="color" id="col1" value="#369292">
 		<label>2</label>
 		<input type="color" id="col2" value="#2e4852">
 		<label>3</label>
 		<input type="color" id="col3" value="#0accca">
 		<label>4</label>
 		<input type="color" id="col4" value="#0accca">
 		<label>5</label>
 		<input type="color" id="col5" value="#0accca">
 		<p></p>
 		<label>6</label>
 		<input type="color" id="col6" value="#369292">
 		<label>7</label>
 		<input type="color" id="col7" value="#2e4852">
 		<label>8</label>
 		<input type="color" id="col8" value="#0accca">
 		<label>9</label>
 		<input type="color" id="col9" value="#0accca">
 		<label>10</label>
 		<input type="color" id="col10" value="#0accca">
 		<p></p>
 		<button onclick="randomizeValues()">Randomize Parameters</button>
 		<button onclick="importCanvas()">Save Image</button>
 		<p></p>
 		<script id="2d-vertex-shader" type="x-shader/x-vertex">
		//Vertex Shader, just a pass=through, does nothing out of the ordinary
		attribute vec2 a_position;
  		void main() {
    		gl_Position = vec4(a_position, 0, 1);
  		}
		</script>

 		<script id="2d-fragment-shader" type="x-shader/x-fragment">
		//Fragment shader, does all the work!
		// Here we initialize the float precision (this really should bea  default thing, took me like an hour to figure out)
		#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
  		#else
    		precision mediump float;
  		#endif

  		// Uniform for the resolution of the CANVAS! (not the screen) and normalized mouse position
  		uniform vec2 u_points[10];
  		uniform vec3 u_colors[10];
  		void main() {
  			//Normalize the frag coord to [0, 1]
  			vec2 uv = gl_FragCoord.xy / vec2(400.0, 400.0);

  			vec2 cPos = vec2(0.5, 0.5);

  			float dist = distance(cPos, uv);

  			float percentages[10];

  			for(int i = 0; i < 10; i++) {
  				float d = distance(u_points[i], uv);
  				float p = 1.0 - smoothstep(0.0, 0.5, d);
  				percentages[i] = p;
  			}

    		//Calculate the background gradient along y using basic mix function
    		vec4 background = vec4(0.75, 0.68, 0.05, 1.0);
    		for(int i = 0; i < 10; i++) {
    			background.rgb = mix(background.rgb, u_colors[i], percentages[i]);
    		}

    		background = background + smoothstep(0.44, 0.45, dist);
    
			gl_FragColor = background;
		}
		</script>

 		<script>
 		// grab the canvas and the gl context
		var canvas = document.getElementById('glscreen');
		var gl = canvas.getContext('experimental-webgl');
		var body = document.body;
		var buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

		gl.bufferData(
			gl.ARRAY_BUFFER, 
			new Float32Array([
					-1.0, -1.0, 
					1.0, -1.0, 
					-1.0,  1.0, 
					-1.0,  1.0, 
					1.0, -1.0, 
					1.0,  1.0]), 
			gl.STATIC_DRAW
		);

		var velocities = getRandomArray(-0.002, 0.002, 20);
		var points = getRandomArray(0.0, 1.0, 20);
		var colors = new Array();

		gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

		//define the shader variables that we'll need
		var shaderScript;
		var shaderSource;
		var vertexShader;
		var fragmentShader;

		// compile the vertex shader
		shaderScript = document.getElementById("2d-vertex-shader");
		shaderSource = shaderScript.text;
		vertexShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vertexShader, shaderSource);
		gl.compileShader(vertexShader);
		
		//compile the fragment shader
		shaderScript   = document.getElementById("2d-fragment-shader");
		shaderSource   = shaderScript.text;
		fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fragmentShader, shaderSource);
		gl.compileShader(fragmentShader);

		program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);	
		gl.useProgram(program);

		function getRandomArray(low, high, size) {
			var points = new Array();
			for(var i = 0; i < size; i++) {
				points[i] = map_range(Math.random(), 0.0, 1.0, low, high);
			}
			return points;
		}

		function map_range(value, low1, high1, low2, high2) {
    		return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
		}

		function hexToRgb(hex) {
		    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		    return result ? {
		        r: parseInt(result[1], 16),
		        g: parseInt(result[2], 16),
		        b: parseInt(result[3], 16)
		    } : null;
		}

		function animatePoints(points, vels) {
			for(var i = 0; i < points.length; i++) {
				points[i] += vels[i];
				if(points[i] < 0) {
					points[i] = 0;
					vels[i] *= -1;
				}
				if(points[i] > 1) {
					points[i] = 1;
					vels[i] *= -1;
				}
			}
		}

		function downloadURI(uri, name) {
			var link = document.createElement("a");
			link.download = name;
			link.href = uri;
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			delete link;
		}

		function importCanvas() {
			var ctxS = new C2S(400, 400);

			drawScene(ctxS);

			var svg = ctxS.getSerializedSvg(true);

			var svg = "data:image/svg+xml;charset=utf-8," + svg;

			downloadURI(svg, "image.svg");
		}

		function setParameters() {
			var cols = new Array();
			cols[0] = document.getElementById("col1").value;
			cols[1] = document.getElementById("col2").value;
			cols[2] = document.getElementById("col3").value;
			cols[3] = document.getElementById("col4").value;
			cols[4] = document.getElementById("col5").value;
			cols[5] = document.getElementById("col6").value;
			cols[6] = document.getElementById("col7").value;
			cols[7] = document.getElementById("col8").value;
			cols[8] = document.getElementById("col9").value;
			cols[9] = document.getElementById("col10").value;
			for(var i = 0; i < cols.length; i+=3) {
				colors[i  ] = hexToRgb(cols[i]).r / 255;
				colors[i+1] = hexToRgb(cols[i]).g / 255;
				colors[i+2] = hexToRgb(cols[i]).b / 255;
			}
		}

		function animate() {
			setParameters();
			animatePoints(points, velocities);
			//clear the buffer
			gl.clearColor(1.0, 1.0, 1.0, 1.0);
			gl.clear(gl.COLOR_BUFFER_BIT);

			// set vertex shader attributes
			positionLocation = gl.getAttribLocation(program, "a_position");
			gl.enableVertexAttribArray(positionLocation);
			gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

			//set fragment shader uniform
			var pointsLoc = gl.getUniformLocation(program, "u_points");
			//var mouseX = 0.5;
			//var mouseY = 0.5;
			//mouseY = 1.0 - mouseY; // flip mouse y because it comes in upside down for the shader coordinate space.
			gl.uniform2fv(pointsLoc, points);

			var colorsLoc = gl.getUniformLocation(program, "u_colors");
			gl.uniform3fv(colorsLoc, colors);

			//draw the triangles with the shaders!
			gl.drawArrays(gl.TRIANGLES, 0, 6);

			requestAnimationFrame(function() {
				animate();
			});
		}

		animate();
	</script>
</body>
</html>
